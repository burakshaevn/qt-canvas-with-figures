# Создание и использование контейнерных классов

Задачи, которые необходимо реализовать в л/р 6:

1. **Добавить в ранее созданный проект еще один программный модуль, предназначенный для реализации контейнерного класса на базе массива или линейного списка.**

При запуске программы выходит InpudDialog, в котором пользователь выбирает контейнер, в котором будут храниться фигуры: DynamicArray (динамический массив) и DynamicList (динамический линейный список).
<div align="center">
  <img src="https://github.com/user-attachments/assets/299cf963-1e20-44d2-9ca5-896b148f4870" alt="image"> 
</div> 

2. **В разделе интерфейса этого модуля:**
* подключить модуль с графической библиотекой;
* описать либо базовый класс контейнера-массива, либо два класса – класс элементов списка и класс самого контейнера-списка.

Определение контейнеров хранятся в dynamic_array.h и dynamic_list.h, реализация хранится в dynamic_array.cpp и dynamic_list.cpp.

При работе с **динамическим массивом**, то его принцип работы похож на вектор: если памяти для вставки нового элемента недостаточно, происходит реалокация памяти — это перераспределение памяти, в результате которого она может уменьшаться или увеличиваться в размере (то есть при добавлении новых элементов или удалении старых):

```cpp
void DynamicArray::push_back(std::unique_ptr<Figure> figure) {
    if (size_ >= capacity_) {
        Resize(capacity_ == 0 ? 1 : capacity_ * 2); // релокация памяти
    }
    data_[size_++] = std::move(figure);
}
```

При работе с **динамическим линейным списком** происходит выделение памяти под ячейку  в куче и присваивание указателя на неё к предыдущему элементу:

```cpp
void DynamicList::push_back(std::unique_ptr<Figure> figure) {
    auto new_node = std::make_unique<Node>(std::move(figure));
    if (!tail) {
        // Если список пустой, делаем новый узел головой и хвостом
        head = std::move(new_node);
        tail = head.get();
    } else {
        // Добавляем элемент в конец и обновляем хвост
        tail->next = std::move(new_node);
        tail = tail->next.get();
    }
    ++size_;
}
```
3. **В разделе реализации записать код всех методов описанных классов. Особое место среди методов контейнера занимает метод-итератор, который организует проход по массиву или списку и с каждым объектом-примитивом выполняет заданное действие. В простейшем случае итератор можно оформить как метод, принимающий входной параметр-признак выполняемого действия. Внутри метода с помощью инструкции Case можно выбрать требуемое действие и внутри цикла применить его к каждому объекту. Можно предусмотреть выполнение следующих действий: перемещение примитива на заданное смещение, показ/стирание примитива, уничтожение примитива со стиранием.**

Оба класса-контейнера имеют одинаковые методы:
```cpp
    void Iterate(const ActionType action, const size_t index, const int dx = 0, const int dy = 0);
    void Iterate(const ActionType action, const int dx = 0, const int dy = 0);
```
Первый метод работает только с указанным индексом, второй со всем контейнером.

Примеры вызовов метода итератора в mainwindow.cpp:
```
453 | container.Iterate(ActionType::ERASE, i);
476 | container.Iterate(ActionType::HIDE, i); 
597 | container.Iterate(ActionType::MOVE, general_count, dx, dy);
726 | container.Iterate(ActionType::SHOW);
```

4. **В разделе реализации главного модуля подключить контейнерный модуль, ввести переменную-указатель на объект-контейнер и переменную-указатель на любой примитив (типа Figure).**
```cpp
class MainWindow : public QMainWindow 
{
    using Container = std::variant<DynamicArray, DynamicList>;
	// ...
private:
    // ...
    Container figures_; // Полиморфный контейнер
```
Изначально мы объявляем, что будем использовать псевдоним `Container`, который будет содержать в себе либо DynamicArray, либо DynamicList. А финальный тип данных выбирается уже в функции ChooseContainerType().

5.  **Добавить в основное меню команду Контейнер с элементами Создать, Добавить, Переместить, Уничтожить.**

В классе главного окна есть метод — ChooseContainerType(). Эта функция вызывается в конструкторе класса MainWindow. Таким образом, при создании главного окна у нас прежде чем оно выведется, будет выведено маленькое окно, где программа будет запрашивать тип контейнера, где будут храниться фигуры.

6.  **Написать обработчик команды Создать, в котором с помощью конструктора создается пустой контейнер и выводится информационное сообщение.**

После выбора пользователя в выпадающем списке нужного контейнера, происходит инициализация переменной figures_
```cpp
void MainWindow::ChooseContainerType() {
    QStringList options = {"DynamicArray", "DynamicList"};
    bool ok;
    QString choice = QInputDialog::getItem(this, "Выбор контейнера", "Выберите контейнер:", options, 0, false, &ok);

    if (ok) {
        if (choice == "DynamicArray") {
            figures_.emplace(std::in_place_type_t<DynamicArray>{});
        } else if (choice == "DynamicList") {
            figures_.emplace(std::in_place_type_t<DynamicList>{});  
        }
    } else {
        QMessageBox::warning(this, "Ошибка", "Контейнер не выбран. Приложение будет закрыто.");
        exit(0);
    }
}
```
При запуске программы, в окне вывода приложения, нам пишет «`QWindowsWindow:: ...`». Это просто предупреждение (Warning) о том как лучше указывать размеры окна в Windows. Его можно проигнорировать. 
<div align="center">
  <img src="https://github.com/user-attachments/assets/8a14d415-b3a4-4c38-8cdc-0ba3cbafa417" alt="image"> 
</div> 

Конструктор по умолчанию и сообщение о создании для **динамического массива**:
```cpp
DynamicArray::DynamicArray(){
    qDebug() << "Создан контейнер DynamicArray";
}
```

Конструктор по умолчанию и сообщение о создании для **динамического линейного списка**:
```cpp
DynamicList::DynamicList(){
    qDebug() << "Создан контейнер DynamicList";
}
```

7. **Написать обработчик команды Добавить, в котором создать случайный примитив со случайными параметрами, добавить его в контейнер и показать методом Show.**

Принцип создания случайного примитива со случайными параметрами: Все типы → Указываем нужное количество фигур → Создать. Создаётся указанное количество случайных примитивов со случайными параметрами.

8. **Написать обработчик команды Переместить, который лишь вызывает итератор с соответствующими параметрами.**

В местах, где требуется вызов MoveTo, теперь вызывается метод Iterate.

```
77  | container.Iterate(ActionType::MOVE, i, dx, dy);
597 | container.Iterate(ActionType::MOVE, general_count, dx, dy);
635 | container.Iterate(ActionType::MOVE, i, dx, dy);
```

В самом методе Iterate, в конструкции множественного выбора (switch-case), реализация выглядит так:
```cpp
switch (action) {
	case ActionType::MOVE:
		current->figure->MoveTo(dx, dy);
		break;
	// ...
```

9. **Написать обработчик команды Уничтожить, который с помощью итератора уничтожает все объекты-примитивы, затем уничтожает методом Free сам контейнер и выводит об этом сообщение.** 

В местах, где требуется вызов функции удаления, теперь вызывается метод Iterate.
```
453 | container.Iterate(ActionType::ERASE, i);
```

В самом методе Iterate, в конструкции множественного выбора (switch-case), реализация выглядит так:
```cpp
switch (action) {
	// ...
	case ActionType::ERASE:
		current->figure->RemoveFromScene();
		erase(index);
		break;
	// ...
```
